// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract CoinFlip {
    address payable owner;
    uint256 public minBet;
    uint256 public maxBet;

    constructor() {
        owner = payable(msg.sender);
        minBet = 0.01 ether;  // minimum bet amount
        maxBet = 10 ether;    // maximum bet amount
    }

    function flipCoin(bool choice) public payable {
        require(msg.value >= minBet && msg.value <= maxBet, "Bet amount is outside of allowable range.");
        uint256 blockNumber = block.number + 1;
        bytes32 blockHash = blockhash(blockNumber);
        require(blockHash != 0, "Blockhash not available yet.");
        uint256 randomNumber = uint256(blockHash) % 2;
        if (randomNumber == 0 && choice == true) {
            // user wins, pay out double the bet amount
            uint256 payout = msg.value * 2;
            require(payout <= address(this).balance, "Contract does not have sufficient balance to pay out winnings.");
            payable(msg.sender).transfer(payout);
        } else if (randomNumber == 1 && choice == false) {
            // user wins, pay out double the bet amount
            uint256 payout = msg.value * 2;
            require(payout <= address(this).balance, "Contract does not have sufficient balance to pay out winnings.");
            payable(msg.sender).transfer(payout);
        } else {
            // user loses, contract keeps the bet amount
            owner.transfer(msg.value);
        }
    }

    function withdraw() public {
        require(msg.sender == owner, "Only the contract owner can withdraw funds.");
        payable(msg.sender).transfer(address(this).balance);
    }
}


// In this contract, the flipCoin() function takes a boolean argument (choice) that represents the user's bet
// on either head (true) or tail (false). If the user wins (i.e., the random number generated by hashing the next block
// matches their bet), they are paid out double the bet amount. If the user loses, the contract keeps the bet amount.
// The withdraw() function allows the contract owner to withdraw any funds in the contract.


// It is theoretically possible for a user to guess the result of the coin flip by trying to predict the hash of the next block. 
// However, this is extremely difficult and unlikely, as the hash of the next block is determined by a number of unpredictable factors,
// such as the timing of transactions, the network's computational power, and more. Additionally, the fact that the
// blockhash() function can only access the hash of the previous 256 blocks makes it even harder to predict the result. 
// Therefore, as long as the blockhash() function is used correctly and the contract is implemented securely, 
// it is highly unlikely that a user would be able to consistently win by guessing the result.







