// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract RandomnessKeccak {

    
    function flip(bool _input) public view returns (bool) {
        uint256 randomnumber = uint256(keccak256(abi.encodePacked(block.timestamp, msg.sender))) % 100;
        if (randomnumber < 50) {
            return !_input;
        } else {
            return _input;
        }
    }
}

// In Solidity, it's difficult to generate truly random numbers.
// However, one common method for generating random numbers is to use the keccak256 hash function,
// which takes an input and produces a unique 256-bit hash value.

// In the flip function, we use keccak256 to generate a hash value based on two inputs: the current block timestamp and 
// the address of the caller. Because the timestamp and the address are both unpredictable, 
// this ensures that the resulting hash value is also unpredictable.

// We then take the resulting hash value and convert it to a uint256 integer using uint256(hashValue). 
// We then use the modulo operator % to get the remainder of dividing this integer by 100. 
// This gives us a number between 0 and 99, which we can use to determine 
// whether the result of the coin flip is heads or tails.

// If the resulting number is less than 50, the function returns 
// the opposite of the input (i.e. if _input is true, the function returns false, and vice versa). 
// Otherwise, the function returns the input as is. Because the number generated by the hash function is 
// random and unpredictable, the result of the flip is also random and unpredictable.
