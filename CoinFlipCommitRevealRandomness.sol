pragma solidity ^0.8.0;

contract Randomness {
    bytes32 public secretValue;
    mapping(address => bytes32) public commitments;
    mapping(bytes32 => uint256) public choices;
    uint256 public numChoices;

    function commit(bytes32 hash) public {
        require(commitments[msg.sender] == 0, "Already committed");
        commitments[msg.sender] = hash;
    }

    function reveal(bytes32 value) public {
        require(secretValue == 0, "Already revealed");
        secretValue = value;
    }

    function submit(bytes32 choice) public {
        require(secretValue != 0, "Secret value not revealed");
        bytes32 hash = keccak256(abi.encodePacked(choice, secretValue));
        require(commitments[msg.sender] == hash, "Invalid commitment");
        require(choices[hash] == 0, "Choice already submitted");
        choices[hash] = ++numChoices;
    }

    function winner() public view returns (bytes32) {
        require(secretValue != 0, "Secret value not revealed");
        bytes32 winnerHash = keccak256(abi.encodePacked(numChoices, secretValue));
        return winnerHash;
    }

    function claim() public {
        bytes32 hash = commitments[msg.sender];
        require(hash != 0, "No commitment found");
        require(choices[hash] != 0, "Choice not submitted");
        bytes32 winnerHash = winner();
        require(hash == winnerHash, "Not a winner");
        uint256 payout = address(this).balance / numChoices;
        payable(msg.sender).transfer(payout);
    }

    function withdraw() public {
        require(msg.sender == owner, "Not authorized");
        payable(owner).transfer(address(this).balance);
    }
}


// In this contract, users first call the commit function to submit a hash of their choice along with the secret value generated by the contract.
// Once all the commitments are made, the contract owner can call the reveal function to reveal the secret value.

// After the secret value is revealed, users can call the submit function to submit their original choice.
// The contract checks that the submitted choice matches the previously submitted hash and that the choice has not already been submitted. 
// If the choice is valid, the contract stores the choice along with a unique ID in the choices mapping.

// Once all the choices are submitted, the contract can determine the winner by calling the winner function.
// This function calculates the hash of the total number of choices along with the secret value, and returns the resulting hash.





